(lambda f: lambda *args: f(f, *args))(lambda self, word, guesses, max_guesses, guesses_left: print(f'You won!\nThe word was: {word}') if any([(lambda f: lambda *args: f(f, *args))(lambda self, word, guesses, max_guesses, is_callback, status, parse: parse(parse, input(status(word, guesses, max_guesses, is_callback)), guesses, max_guesses, status, self) if is_callback else guesses.append(parse(input(status(word, guesses, max_guesses, is_callback)), guesses, max_guesses, status, self)))(word, guesses, max_guesses, False, lambda word, guesses, max_guesses, invalid: ('Invalid input: must be only one letter that has not yet been guessed.\n' if invalid else '') + ' '.join([letter if letter in guesses else '_' for letter in word]) + f'\tGuesses left: {guesses_left(word, guesses, max_guesses)}' '\nPick a letter: ', (lambda f: lambda *args: f(f, *args))(lambda self, guess, guesses, max_guesses, status, get_guess: guess.strip().lower() if len(guess) == 1 and guess.isalpha() and guess not in guesses else get_guess(get_guess, word, guesses, max_guesses, True, status, self))), all([True if letter in guesses else False for letter in word])]) else (print(f'You lost.\nThe word was: {word}') if guesses_left(word, guesses, max_guesses) <= 0 else self(self, word, guesses, max_guesses, guesses_left)))(__import__('random').choice([word.strip() for word in open('/usr/share/dict/words').readlines() if len(word) >= 3 and not word[0].isupper()]), [], 6, lambda word, guesses, max_guesses: max_guesses - len([guess for guess in guesses if guess not in word]))